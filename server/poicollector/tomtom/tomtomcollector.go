/*
Package TomTom implements API access to TomTom Maps APIs

See https://developer.tomtom.com/tomtom-maps-apis-developers
*/

package tomtom

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	pbContext "xevo/physeter-context-server/proto"
	"xevo/physeter-context-server/server/types"
)

const (
	apiKey      = "yHZ8ehvgD2GprGuQ3PRjfQVQc0YhPZ7q"
	apiEndpoint = "https://api.tomtom.com/search/2/search/%s.json?%s"
	countrySet  = "US"
)

var keywords = [...]string{"parking", "petrol station", "restaurant", "cafe", "school", "grocery"}

// Collector retrieves POI information by TomTom Online Search API https://developer.tomtom.com/online-search/online-search-documentation/search
type Collector struct {
}

var _ types.PoiCollector = (*Collector)(nil)

// APIResponse is response object of latlon search result. This type is auto-generated by https://mholt.github.io/json-to-go/
type APIResponse struct {
	Results []struct {
		Address struct {
			Country                     string `json:"country"`
			CountryCode                 string `json:"countryCode"`
			CountryCodeISO3             string `json:"countryCodeISO3"`
			CountrySecondarySubdivision string `json:"countrySecondarySubdivision"`
			CountrySubdivision          string `json:"countrySubdivision"`
			CountrySubdivisionName      string `json:"countrySubdivisionName"`
			CountryTertiarySubdivision  string `json:"countryTertiarySubdivision"`
			ExtendedPostalCode          string `json:"extendedPostalCode"`
			FreeformAddress             string `json:"freeformAddress"`
			Municipality                string `json:"municipality"`
			MunicipalitySubdivision     string `json:"municipalitySubdivision"`
			PostalCode                  string `json:"postalCode"`
			StreetName                  string `json:"streetName"`
			StreetNumber                string `json:"streetNumber"`
		} `json:"address"`
		Dist        float64 `json:"dist"`
		EntryPoints []struct {
			Position struct {
				Lat float64 `json:"lat"`
				Lon float64 `json:"lon"`
			} `json:"position"`
			Type string `json:"type"`
		} `json:"entryPoints"`
		ID   string `json:"id"`
		Info string `json:"info"`
		Poi  struct {
			Categories      []string `json:"categories"`
			Classifications []struct {
				Code  string `json:"code"`
				Names []struct {
					Name       string `json:"name"`
					NameLocale string `json:"nameLocale"`
				} `json:"names"`
			} `json:"classifications"`
			Name  string `json:"name"`
			Phone string `json:"phone"`
			URL   string `json:"url"`
		} `json:"poi"`
		Position struct {
			Lat float64 `json:"lat"`
			Lon float64 `json:"lon"`
		} `json:"position"`
		Score    float64 `json:"score"`
		Type     string  `json:"type"`
		Viewport struct {
			BtmRightPoint struct {
				Lat float64 `json:"lat"`
				Lon float64 `json:"lon"`
			} `json:"btmRightPoint"`
			TopLeftPoint struct {
				Lat float64 `json:"lat"`
				Lon float64 `json:"lon"`
			} `json:"topLeftPoint"`
		} `json:"viewport"`
	} `json:"results"`
	Summary struct {
		FuzzyLevel int `json:"fuzzyLevel"`
		GeoBias    struct {
			Lat float64 `json:"lat"`
			Lon float64 `json:"lon"`
		} `json:"geoBias"`
		NumResults   int    `json:"numResults"`
		Offset       int    `json:"offset"`
		Query        string `json:"query"`
		QueryTime    int    `json:"queryTime"`
		QueryType    string `json:"queryType"`
		TotalResults int    `json:"totalResults"`
	} `json:"summary"`
}

// Name returns the name of the collector
func (c *Collector) Name() string {
	return "TomTomCollector"
}

type response struct {
	*APIResponse
	error
}

// Collect retrieves POIs from TomTom Search API and returns a list of PointOfInterest
func (c *Collector) Collect(req *pbContext.GetRecommendsRequest) ([]*pbContext.PointOfInterest, error) {
	if err := validateRequest(req); err != nil {
		return nil, err
	}

	var location = req.CarState.CurrentLocation

	ch := make(chan response)

	for _, keyword := range keywords {
		go getTomTomAPIResponse(keyword, location.Latitude, location.Longitude, ch)
	}

	var responses [len(keywords)]response
	pois := make([]*pbContext.PointOfInterest, 0)

	for i := range responses {
		responses[i] = <-ch
		if responses[i].APIResponse != nil {
			converted := tomtomconvertToPois(responses[i].APIResponse)
			pois = append(pois, converted...)
		}
	}

	// Todo: return error
	return pois, nil
}

func validateRequest(req *pbContext.GetRecommendsRequest) error {
	if req == nil {
		return fmt.Errorf("Request object must not be nil")
	}
	if req.CarState == nil || req.CarState.CurrentLocation == nil {
		return fmt.Errorf("The car location is required")
	}
	return nil
}

func getTomTomAPIResponse(keyword string, latitude float64, longitude float64, c chan response) {
	qs := url.Values{
		"key":        {apiKey},
		"countrySet": {countrySet},
		"lat":        {fmt.Sprintf("%f", latitude)},
		"lon":        {fmt.Sprintf("%f", longitude)},
		"limit":      {"10"},
		"radius":     {"5000"},
	}

	remote := fmt.Sprintf(apiEndpoint, keyword, qs.Encode())
	fmt.Printf("Get: %s\n", remote)

	resp, err := http.Get(remote)
	if err != nil {
		c <- response{nil, err}
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		p, _ := ioutil.ReadAll(resp.Body)
		c <- response{nil, fmt.Errorf("get %s returned status %d, %s", resp.Request.URL, resp.StatusCode, p)}
	}

	var result APIResponse
	err = json.NewDecoder(resp.Body).Decode(&result)
	if err != nil {
		c <- response{nil, err}
	}
	c <- response{&result, nil}
}

func tomtomconvertToPois(resp *APIResponse) []*pbContext.PointOfInterest {

	fmt.Printf("Success to get the TomTom Search API. query='%s' bias=(%f,%f) count=%d\n",
		resp.Summary.Query,
		resp.Summary.GeoBias.Lat,
		resp.Summary.GeoBias.Lon,
		resp.Summary.TotalResults,
	)
	result := make([]*pbContext.PointOfInterest, 0, 10)
	var items = resp.Results
	for _, item := range items {
		var poi = item.Poi
		categories := convertToTomTomPoiCategory(poi.Categories)
		if len(categories) == 0 {
			continue
		}
		p := pbContext.PointOfInterest{
			Name: poi.Name,
			Coordinates: &pbContext.GeoCoordinates{
				Location: &pbContext.Coordinates{
					Latitude:  item.Position.Lat,
					Longitude: item.Position.Lon,
				},
				Address:        item.Address.FreeformAddress,
				AddressCountry: item.Address.CountryCode,
				PostalCode:     item.Address.PostalCode,
			},
			Categories: categories,
			Distance:   item.Dist,
		}
		result = append(result, &p)
	}
	return result
}

// List of categories https://developer.tomtom.com/online-search/online-search-documentation-search/category-search
func convertToTomTomPoiCategory(categories []string) []pbContext.PointOfInterest_Category {
	for _, category := range categories {
		switch true {
		case strings.Index(category, "parking") != -1:
			return []pbContext.PointOfInterest_Category{pbContext.PARKING}
		case category == "petrol station":
			return []pbContext.PointOfInterest_Category{pbContext.GAS_STATION}
		case category == "cafeterias" || category == "cafÃ©":
			return []pbContext.PointOfInterest_Category{pbContext.CAFE}
		case category == "restaurant":
			return []pbContext.PointOfInterest_Category{pbContext.RESTAURANT}
		case category == "school":
			return []pbContext.PointOfInterest_Category{pbContext.SCHOOL}
		case category == "shop":
			return []pbContext.PointOfInterest_Category{pbContext.GROCERY}
		}
	}
	return []pbContext.PointOfInterest_Category{}
}
